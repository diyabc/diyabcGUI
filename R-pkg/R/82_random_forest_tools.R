#' Run training set simulation
#' @keywords internal
#' @author Ghislain Durif
#' @details
#'  -h, --header arg        Header file (default: headerRF.txt)
#'  -r, --reftable arg      Reftable file (default: reftableRF.bin)
#'  -b, --statobs arg       Statobs file (default: statobsRF.txt)
#'  -o, --output arg        Prefix output (modelchoice_out or estimparam_out by
#'                                         default)
#'  -n, --nref arg          Number of samples, 0 means all (default: 0)
#'  -m, --minnodesize arg   Minimal node size. 0 means 1 for classification or
#'  5 for regression (default: 0)
#'  -t, --ntree arg         Number of trees (default: 500)
#'  -j, --threads arg       Number of threads, 0 means all (default: 0)
#'  -s, --seed arg          Seed, generated by default (default: 0)
#'  -c, --noisecolumns arg  Number of noise columns (default: 5)
#'  --nolinear          Disable LDA for model choice or PLS for parameter
#'  estimation
#'  --plsmaxvar arg     Percentage of maximum explained Y-variance for
#'  retaining pls axis (default: 0.9)
#'  --chosenscen arg    Chosen scenario (mandatory for parameter
#'                                       estimation)
#'  --noob arg          number of oob testing samples (mandatory for
#'                                                     parameter estimation)
#'  --parameter arg     name of the parameter of interest (mandatory for
#'                                                         parameter estimation)
#'  -g, --groups arg        Groups of models
abcranger_run <- function(proj_dir, run_mode, n_rec, 
                          min_node_size, n_tree, noise_columns, no_linear, 
                          pls_max_var, chosen_scenario, noob, parameter, 
                          groups = NULL) {
    # # debugging
    # pprint("abcranger args")
    # pprint(match.call())
    
    # executable
    abcranger_bin <- find_bin("abcranger")
    
    # check project dir
    if(!dir.exists(proj_dir)) {
        stop("Input directory does not exist")
    }
    
    # check for required files
    required_files <- c("headerRF.txt", "statobsRF.txt", "reftableRF.bin")
    if(!all(required_files %in% list.files(proj_dir))) {
        stop("missing required input file(s)")
    }
    
    ### run
    logging("abcranger run")
    arguments <- c(
        "-n", as.character(n_rec),
        "-m", as.character(min_node_size),
        "-t", as.character(n_tree),
        "-j", as.character(getOption("diyabcGUI")$ncore),
        "-c", as.character(noise_columns)
    )
    if(no_linear) {
        arguments <- c(arguments, "--no_linear")
    } else {
        arguments <- c(arguments, "--plsmaxvar", as.character(pls_max_var))
    }
    if(run_mode == "param_estim") {
        arguments <- c(
            arguments,
            "--chosenscen", as.character(chosen_scenario),
            "--noob", as.character(noob),
            "--parameter", as.character(parameter)
        )
    } else if(run_mode == "model_choice") {
        if(!is.null(groups)) {
            if(is.character(groups) & str_length(groups) > 0) {
                arguments <- c(arguments, "-g", groups)
            }
        }
    }
    
    run_proc <- processx::process$new(
        command = abcranger_bin, 
        args = arguments,
        stdin = "|",
        stdout = file.path(proj_dir, "abcranger_call.log"), 
        stderr = file.path(proj_dir, "abcranger_call.log"),
        echo_cmd = TRUE,
        wd = proj_dir
    )
    
    ## output process
    return(run_proc)
}

#' Clean up after abcranger
#' @keywords internal
#' @author Ghislain Durif
cleanup_abcranger_run <- function(project_dir) {
    # ## file list
    # files <- file.path(
    #     project_dir,
    #     c("abcranger_param_estim_call.log", 
    #       "abcranger_mod_choice_call.log")
    # )
    # # remove files
    # lapply(files, function(filename) {
    #     if(file.exists(filename)) {
    #         fs::file_delete(filename)
    #     }
    # })
}


#' Parse abcranger group arg
#' @keywords internal
#' @author Ghislain Durif
#' @description
#' For example, with six models, labeled from 1 to 6,",
#' `'1,2,3;4,5,6'` to make 2 groups of 3.
parse_abcranger_group <- function(txt, n_scenario) {
    valid <- TRUE
    msg <- list()
    # check input
    if(!is.null(txt) | !is.character(txt)) {
        # strip "|'
        tmp <- str_replace_all(txt, pattern = "\"|'", replacement = "")
        # check format
        pttrn <- "^([0-9]+(,[0-9]+)*)(;([0-9]+(,[0-9]+)*))*$"
        if(!str_detect(tmp, pttrn)) {
            valid <- FALSE
            msg <- append(
                msg,
                str_c(
                    "Issue with group formating. Use only",
                    "numbers, commas (,) and semi-colons (;).", sep = " "
                )
            )
        } else {
            # at least 2 groups
            if(!str_detect(tmp, ";")) {
                valid <- FALSE
                msg <- append(
                    msg,
                    str_c(
                        "You should specify at least two groups,",
                        "separated by semi-colons (;).",
                        "If you do not want to group scenarii",
                        "(or equivalently assign each scenario",
                        "to its own group), leave blank.",
                        sep = " "
                    )
                )
            }
            # extract information
            pttrn <- "[0-9]+"
            scenario_list <- as.numeric(
                str_extract_all(tmp, pttrn, simplify = TRUE)
            )
            if(!all((1:n_scenario) %in% scenario_list)) {
                valid <- FALSE
                msg <- append(
                    msg,
                    str_c(
                        "Some scenarii are missing in scenario grouping:", 
                        str_c(
                            (1:n_scenario)[!(1:n_scenario) %in% scenario_list],
                            collapse = ", "
                        ),
                        sep = " "
                    )
                )
            }
            if(!all(scenario_list %in% (1:n_scenario))) {
                valid <- FALSE
                msg <- append(
                    msg,
                    str_c(
                        "Some scenarii listed in scenario grouping",
                        "does not exist:",
                        str_c(
                            scenario_list[!scenario_list %in% (1:n_scenario)],
                            collapse = ", "
                        ),
                        sep = " "
                    )
                )
            }
        }
    }
    return(lst(msg, valid))
}


#' Abcranger postprocessing
#' @keywords internal
#' @author Ghislain Durif
#' @description
#' After a successfool abcranger run, result postprocessing includes graphical 
#' output generation.
abcranger_postprocess <- function(proj_dir, graph_dir, 
                                  run_mode = "param_estim", 
                                  prefix = "estimparam_out", 
                                  sub_proj_name = NULL,
                                  param = NULL) {
    # graphical output
    if(run_mode == "param_estim") {
        # parameter estimation
        if(!is.null(param)) {
            param_estim_graph_ouptut(proj_dir, graph_dir, param, prefix)
        }
        # move file to subproject directory
        abcranger_subdir(proj_dir, sub_proj_name, prefix = "estimparam_out")
    } else if(run_mode == "model_choice") {
        # model choice
        model_choice_graph_ouptut(proj_dir, graph_dir, prefix)
        # move file to subproject directory
        abcranger_subdir(proj_dir, sub_proj_name, prefix = "modelchoice_out")
    }
}

#' Abcranger sub-project directory management
#' @keywords internal
#' @author Ghislain Durif
#' @description
#' After a successfool abcranger run, result files are moved to a dedicated 
#' sub-directory
abcranger_subdir <- function(proj_dir, sub_proj_name, prefix) {
    if(!is.null(sub_proj_name)) {
        if(str_length(sub_proj_name) > 0) {
            # create sub-directory
            sub_dir_path <- file.path(proj_dir, sub_proj_name)
            if(!dir.exists(sub_dir_path)) {
                fs::dir_create(sub_dir_path)
            }
            # move output files
            tmp_file_list <- list.files(proj_dir, pattern = prefix)
            if(length(tmp_file_list) > 0) {
                tmp_file_info <- file.info(file.path(proj_dir, tmp_file_list))
                if(any(!tmp_file_info$isdir)) {
                    tmp_file_list <- tmp_file_list[!tmp_file_info$isdir]
                    tmp_move <- lapply(
                        tmp_file_list, 
                        function(tmp_file) {
                            fs::file_copy(
                                path = file.path(proj_dir, tmp_file),
                                new_path = file.path(sub_dir_path, tmp_file),
                                overwrite = TRUE
                            )
                            fs::file_delete(file.path(proj_dir, tmp_file))
                        }
                    )
                }
            }
        }
    }
}
